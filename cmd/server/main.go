package main

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"sync"

	"connectrpc.com/connect"
	todov1 "example.com/todo/gen/todo/v1" // generated by protoc-gen-go
	"example.com/todo/gen/todo/v1/todov1connect"
	"github.com/google/uuid"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
)

type ToDoServer struct{
	m sync.Map
}

func (s *ToDoServer) Read(
	ctx context.Context,
	req *connect.Request[todov1.ReadRequest],
) (*connect.Response[todov1.ReadResponse], error) {
	todo, ok := s.m.Load(req.Msg.Id)
	println("todo")
	fmt.Printf("%v", todo)
	println("-----------------")
	if ok {

		fmt.Print(s.m.Load(req.Msg.Id))

		res := connect.NewResponse(&todov1.ReadResponse{
			Todo: todo.(*todov1.ToDo),
		})
		return res, nil
	}
	err := status.Error(codes.NotFound, req.Msg.Id+" is not found")
	return nil, err
}

func (s *ToDoServer) Create(
	ctx context.Context,
	req *connect.Request[todov1.CreateRequest],
) (*connect.Response[todov1.CreateResponse], error) {
	fmt.Printf("%v", req)
	id := uuid.NewString()
	_, ok := s.m.Load(id)
	if ok {
		err := status.Error(codes.AlreadyExists, id+" is already exists")
		return nil, err
	}
	// TODO: validate todo
	println("req.Msg.Status")
	println(req.Msg.Status)
	println("-----------------")
	todo := &todov1.ToDo{
		Id:     id,
		Name:   req.Msg.Name,
		Status: req.Msg.Status,
	}
	s.m.Store(id, todo)

	_, ok = s.m.Load(id)
	if ok {
		log.Println("Request headers: ", req.Header())
		res := connect.NewResponse(&todov1.CreateResponse{
			Todo: todo,
		})
		res.Header().Set("Greet-Version", "v1")
		return res, nil
	}
	err := status.Error(codes.Internal, "failed to create todo")
	return nil, err
}

func (s *ToDoServer) Update(
	ctx context.Context,
	req *connect.Request[todov1.UpdateRequest],
) (*connect.Response[todov1.UpdateResponse], error) {
	log.Println("Request headers: ", req.Header())
	_, ok := s.m.Load(req.Msg.Id)
	if ok {
		todo := &todov1.ToDo{
			Id:     req.Msg.Id,
			Name:   req.Msg.Name,
			Status: req.Msg.Status,
		}
		s.m.Store(req.Msg.Id, todo)
		if updatedTodo, ok := s.m.Load(req.Msg.Id); ok {
			if updatedTodo != todo {
				err := status.Error(codes.Internal, "failed to update todo")
				return nil, err
			}
		}
		fmt.Print(s.m.Load(req.Msg.Id))
		res := connect.NewResponse(&todov1.UpdateResponse{
			Todo: todo,
		})
		res.Header().Set("Greet-Version", "v1")
		return res, nil
	}
	err := status.Error(codes.NotFound, req.Msg.Id+" is not found")
	return nil, err
}

func (s *ToDoServer) Delete(
	ctx context.Context,
	req *connect.Request[todov1.DeleteRequest],
) (*connect.Response[todov1.DeleteResponse], error) {
	log.Println("Request headers: ", req.Header())
	_, ok := s.m.Load(req.Msg.Id)
	if ok {
		s.m.Delete(req.Msg.Id)
		if _, ok := s.m.Load(req.Msg.Id); ok {
			err := status.Error(codes.Internal, "failed to delete todo")
			return nil, err
		}
		fmt.Println("m.load")
		fmt.Print(s.m.Load(req.Msg.Id))
		res := connect.NewResponse(&todov1.DeleteResponse{})
		res.Header().Set("Greet-Version", "v1")
		return res, nil
	}
	err := status.Error(codes.NotFound, req.Msg.Id+" is not found")
	return nil, err
}

func main() {
	greeter := &ToDoServer{}
	mux := http.NewServeMux()
	path, handler := todov1connect.NewToDoServiceHandler(greeter)
	mux.Handle(path, handler)
	http.ListenAndServe(
		"localhost:8080",
		// Use h2c so we can serve HTTP/2 without TLS.
		h2c.NewHandler(mux, &http2.Server{}),
	)
}
